

provide:
   tests
   TestMask
   Test
   TestSuite
   formatTests

   
global.___letest_global = exports


class RaceGen:

   constructor{@promises} =
      @total = 0
      @proms = {}
      @marks = {}
      @add{@promises}

   add{promises} =
      promises each p ->
         mark = {=}
         @marks.push{mark}
         @proms.push{async{{} -> {mark, await p}}{}}
      @total += promises.length

   async! next{} =
      if @proms.length == 0:
         {value = undefined, done = true}
      else:
         {mark, res, var repl = null, valid = true} =
            await Promise.race{@proms}

         i = @marks.indexOf{mark}
         if repl == null:
            @proms.splice{i, 1}
            @marks.splice{i, 1}
         else:
            @proms[i] = repl{}

         if not valid:
            return @next{}

         match res:
            SeqGen? ->
               @total += res.total
               let mark = {=}
               @marks.push{mark}
               mknext{} =
                  async: {} ->
                     x = await res.next{}
                     {mark, x.value, if{x.done, null, mknext{}}, not x.done}
               @proms.push{mknext{}{}}
               @next{}
            RaceGen? ->
               @total += res.total
               @marks ++= res.marks
               @proms ++= res.proms
               @next{}
            else ->
               {value = res, done = false}


class SeqGen:

   constructor{clone! @promises} =
      @total = @promises.length
      @sub = null

   async! next{} =
      if @sub:
         r = await @sub.next{}
         if r.done:
            @sub = null
            @next{}
         else:
            r
      elif @promises.length == 0:
         {value = undefined, done = true}
      else:
         res = await @promises.shift{}{}
         match res:
            RaceGen? or SeqGen? ->
               @total += res.total
               @sub = res
               @next{}
            else ->
               {value = res, done = false}


splitDo{clone! stmts} =
   parts = {}
   var stmt = false
   var test = false

   while stmts.length > 0:
      s = stmts.shift{}
      match s:
         `do: ^b` when parts == {} ->
            #multi! #multi{*contents} = b
            test or= s
            parts.push{#do{contents}}
         `do: ^_` ->
            test or= s
            stmts.unshift{s}
            parts.push{#label{#void{}, #multi{*stmts}}}
            break
         `^x => ^y` ->
            test or= s
            parts.push{#label{x, y}}
         else ->
            stmt or= s
            parts.push{s}

   if stmt and test:
      throw E.letest.syntax{
         "Normal statements define a test and cannot be mixed with do/=>."
         {normstmt = stmt
          teststmt = test}
      }

   {test != false, parts}


tests{ctx, info, form, #data{lbl, _body}} =


   letest = #variable{"___letest_global"}


   parseDescription{match d} =
      #value{String! s} ->
         tags = [s.match{R.g"#[a-zA-Z0-9_-]+"} or {}] each
            tag -> #value{tag.slice{1}}
         {d, `{^*tags}`}
      #void{} ->
         {`""`, `{}`}
      else ->
         throw E.letest.syntax.description{"Invalid description.", {node = d}}


   processBody{body and #multi! #multi{*stmts}, ord} =
      match splitDo{stmts}:
         {_, {}} ->
            throw E.letest.syntax{"Body cannot be empty.", {body = body}}
         {== true, tests} ->
            processSuite{tests, ord}
         {== false, stmts} ->
            gener = `async{{} -> ^[#multi{*stmts}]}`
            descr = `#test{}`
            {gener, descr}


   processSuite{stmts, defaultOrd} =

      {let body, let tests} = match stmts:
         {#do{b}, *rest} ->
            {#multi{*b}, rest}
         xs ->
            {#multi{}, xs}

      var index = 0
      let gene = #data{}
      let descrs = #data{}

      tests each match test ->
         #label{l, body} ->
            {parseDescription! {descr, tags}, ord} = match l:
               `seq ^descr` -> {descr, .seq}
               `seq`        -> {#value{index += 1}, .seq}
               `par ^descr` -> {descr, .par}
               `par`        -> {#value{index += 1}, .par}
               #void{}      -> {#value{index += 1}, defaultOrd}
               descr        -> {descr, defaultOrd}

            {g, s} = processBody{body, ord}
            gene.push with g
            descrs.push with `#label{^descr, ^tags, {^=ord, ^s}}`

      body.push{gene}
      {`async{{} -> ^body}`, `#suite{^descrs}`}

   {v, description, body} = match lbl:
      v and #symbol{name} ->
         {v, #value{"#" + name}, _body}
      #send{v and #symbol{name}, `{^ #value{lbl}}` or #value{lbl}} ->
         {v, #value{String{lbl} + " #" + name}, _body}

   {gene, trees} = processBody{body, .par}
   {d, t} = parseDescription{description}

   `[^v = [^letest].TestSuite{#label{^d, ^t, ^trees}, ^gene}]`


class TestSuite:

   constructor{@descr, @gen} =
      pass

   select{white = true, black = {}} =
      ;; if white == true and black == {}:
      ;;    return TestMask{@descr, @gen, true, 0}

      trim{arr} =
         var i = arr.length - 1
         while i > 0 and arr[i] === false:
            arr.pop{}
            i -= 1
         arr

      var count = 0
      mask = helper{@descr, false} where helper{match, default} =
         #test{} ->
            count += 1
            default
         #par{x} or #seq{x} ->
            helper{x, default}
         #label{d, t, x} ->
            if matchtags{t, black}:
               false
            elif white == true or matchtags{t, white}:
               helper{x, true}
            else:
               helper{x, default}
         #suite{subd} ->
            res = subd each x -> helper{x, default}
            res.every{{x} -> x === true} or [res.some{{x} -> x} and trim{res}]

      TestMask{@descr, @gen, mask, count}

   generator{} =
      @select{true}.generator{}


class Test:
   constructor{@test, @source} =
      pass
   async! execute{} =
      try:
         match [await @test{}]:
            === true ->
               #success{}
            === false ->
               #failure{}
            res and [#success or #failure] ->
               res
            other ->
               #error{E.tests.protocol{..., other}} with
                  "Tests must return true, false, #success{...} or #failure{...}"
      catch error:
         #error{error}


matchtags{tags1, tags2} =
   tags1 each t1 ->
      tags2 each t2 ->
         if t1 == t2:
            return true
      pass
   false


class TestMask:

   constructor{@descr, @gen, @mask, @count = 0} =
      pass

   async! generator{var path = {}, ord = .par} =

      match @descr:
         when @mask === false ->
            RaceGen with {}

         #test{} ->
            async! dotest{} =
               t = Test{@gen, null}
               #testResult{path, t, await t.execute{}}
            RaceGen with {dotest{}}

         {ord in {.par, .seq}, x} ->
            m = TestMask{x, @gen, @mask, @count}
            m.generator{path, ord}

         #label{d, t, x} ->
            if Number? path[path.length - 1]:
               path[path.length - 1] = d
            else:
               path ++= {d}
            m = TestMask{x, @gen, @mask, @count}
            m.generator{path, ord}

         #suite{sub} ->
            var pos = 0
            var gens = {}
            try:
               let tests = await @gen{}
               tests each test ->
                  submask = if{@mask === true, @mask, @mask[pos]}
                  if submask:
                     m = TestMask{sub[pos], test, submask}
                     newpath = if{sub.length == 1, path, path ++ {pos}}
                     gens.push with {} -> m.generator{newpath, ord}
                  pos += 1
            catch error:
               gens.push with {} -> #error{path, error}
            match ord:
               .par -> RaceGen{gens each g -> g{}}
               .seq -> SeqGen{gens}


async! formatTests{tsts} =

   error_reports = {}

   var successes = 0
   var failures = 0
   var errors = 0

   stream = process.stdout
   tick{} =
      stream.clearLine{}
      stream.cursorTo{0}
      stream.write{"Successes: " + successes + ", Failures: " + failures + ", Errors: " + errors}

   fmtp{path} =
      [p.join{" => "}] where p = path each
         Number? n -> "Test #" + n
         s -> s

   tg = await tsts.generator{}
   var curr = await tg.next{}

   while not curr.done:
      test = curr.value
      match test:
         #testResult{path, test, x} ->
            match [await x]:
               #success ->
                  successes += 1
                  tick{}
               #failure ->
                  failures += 1
                  tick{}
                  var report = "FAILURE: " + fmtp{path} + "\n"
                  report += "SOURCE: " + test.source + "\n"
                  error_reports.push with report
               #error{error} ->
                  errors += 1
                  tick{}
                  var report = "ERROR: " + fmtp{path} + "\n"
                  report += "SOURCE: " + test.source + "\n"
                  report += String{error} + "\n"
                  error_reports.push with report
         #error{path, error} ->
            ;; errors += count
            errors += 1
            tick{}
            var report = "ERROR: " + fmtp{path} + "\n"
            report += String{error} + "\n"
            ;; report += count + " tests could not be run because of this error." + "\n"
            error_reports.push with report

      curr = await tg.next{}

   console.log{}

   error_reports each report ->
      console.log with "\n==========="
      console.log with report

   console.log with "Done."

   pass
