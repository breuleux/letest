

provide:
   tests
   TestMask
   Test
   TestSuite
   formatTests

   
global.___letest_global = exports


class RaceGen:

   constructor{@promises} =
      @proms = {}
      @marks = {}
      @add{@promises}

   add{promises} =
      promises each p ->
         mark = {=}
         @marks.push{mark}
         @proms.push{async{{} -> {mark, await p}}{}}

   async! next{} =
      if @proms.length == 0:
         {value = undefined, done = true}
      else:
         {mark, res, var repl = null, valid = true} =
            await Promise.race{@proms}

         i = @marks.indexOf{mark}
         if repl == null:
            @proms.splice{i, 1}
            @marks.splice{i, 1}
         else:
            @proms[i] = repl{}

         if not valid:
            return @next{}

         match res:
            SeqGen? ->
               mark = {=}
               @marks.push{mark}
               mknext{} =
                  async: {} ->
                     x = await res.next{}
                     {mark, x.value, if{x.done, null, mknext{}}, not x.done}
               @proms.push{mknext{}{}}
               @next{}
            RaceGen? ->
               @marks ++= res.marks
               @proms ++= res.proms
               @next{}
            else ->
               {value = res, done = false}


class SeqGen:

   constructor{clone! @promises} =
      @sub = null

   async! next{} =
      if @sub:
         r = await @sub.next{}
         if r.done:
            @sub = null
            @next{}
         else:
            r
      elif @promises.length == 0:
         {value = undefined, done = true}
      else:
         res = await @promises.shift{}{}
         match res:
            RaceGen? or SeqGen? ->
               @sub = res
               @next{}
            else ->
               {value = res, done = false}


tests{ctx, scope, form, #data{descr, _body}} =

   letest = #variable{"___letest_global"}

   parseDescription{match d} =
      #value{String! s} ->
         tags = [s.match{R.g"#[a-zA-Z0-9_-]+"} or {}] each
            tag -> #value{tag.slice{1}}
         {d, `{^*tags}`}
      #void{} ->
         {`""`, `{}`}
      else ->
         throw E.letest.syntax.description{"Invalid description.", {node = d}}

   processSuite{#multi! #multi{*stmts}} =

      {let body, let tests} = match stmts:
         {`do: ^[#multi! #multi{*b}]`, *rest} ->
            {#multi{*b}, rest}
         xs ->
            {#multi{}, xs}

      var index = 0
      let gene = #data{}
      let descrs = #data{}

      tests each match test ->
         `do: ^_` ->
            throw E.letest.syntax{
               "do: statement must be at the beginning of the block."
               {node = test}
            }
         `inorder ^descr => ^b` or `inorder: ^b` and descr is null ->
            {txt, tags} =
               if descr == null:
                  index += 1
                  {#value{index}, `{}`}
               else:
                  parseDescription{descr}
            {g, s} = processSuite{b}
            gene.push with g
            descrs.push with `#seqsuite{^txt, ^tags, ^s}`
         `^descr => ^b` ->
            {txt, tags} = parseDescription{descr}
            {g, s} = processSuite{b}
            gene.push with g
            descrs.push with `#suite{^txt, ^tags, ^s}`
         `inorder: ^b` ->
            txt = #value{index}
            tags = `{}`
            {g, s} = processSuite{b}
            gene.push with g
            descrs.push with `#seqsuite{^txt, ^tags, ^s}`
         `test: ^expr` or expr ->
            gene.push with `async{{} -> ^expr}`
            descrs.push with `#test{^=index, null, null}`
            index += 1

      body.push{gene}
      {`async{{} -> ^body}`, descrs}

   {v, description, body} = match descr:
      v and #symbol{name} ->
         {v, #value{"#" + name}, _body}
      #send{v and #symbol{name}, `{^ #value{descr}}` or #value{descr}} ->
         {v, #value{String{descr} + " #" + name}, _body}

   {gene, trees} = processSuite{body}
   {d, t} = parseDescription{description}

   `[^v = [^letest].TestSuite{#suite{^d, ^t, ^trees}, ^gene}]`


class TestSuite:

   constructor{@descr, @gen} =
      pass

   select{white = true, black = {}} =
      trim{arr} =
         var i = arr.length - 1
         while i > 0 and arr[i] === false:
            arr.pop{}
            i -= 1
         arr

      {_, text, tags, subdescr} = @descr
      var count = 0
      mask = helper{tags, subdescr, false} where
         helper{t, sd, default} =
            if sd === null:
               if default: count += 1
               default
            elif matchtags{t, black}:
               false
            elif white === true or matchtags{t, white}:
               res = sd each {_, _, t, sd} -> helper{t, sd, true}
               res.every{{x} -> x === true} or trim{res}
            else:
               res = sd each {_, _, t, sd} -> helper{t, sd, default}
               res.every{{x} -> x === true} or [res.some{{x} -> x} and trim{res}]

      TestMask{@descr, @gen, mask, count}

   generator{} =
      @select{true}.generator{}


class Test:
   constructor{@test, @source} =
      pass
   async! execute{} =
      try:
         match [await @test{}]:
            === true ->
               #success{}
            === false ->
               #failure{}
            res and [#success or #failure] ->
               res
            other ->
               #error{E.tests.protocol{..., other}} with
                  "Tests must return true, false, #success{...} or #failure{...}"
      catch error:
         #error{error}


matchtags{tags1, tags2} =
   tags1 each t1 ->
      tags2 each t2 ->
         if t1 == t2:
            return true
      pass
   false


class TestMask:

   constructor{@descr, @gen, @mask, @count = 0} =
      pass

   async! generator{var path = {}} =

      match @descr:
         when @mask === false ->
            RaceGen with {}

         #test{*} ->
            async! dotest{} =
               t = Test{@gen, null}
               #testResult{path, t, await t.execute{}}
            RaceGen with {dotest{}}

         {kind in {.suite, .seqsuite}, d, t, sub} ->
            if Number? path[path.length - 1]:
               path[path.length - 1] = d
            else:
               path ++= {d}
            var pos = 0
            var gens = {}
            try:
               let tests = await @gen{}
               tests each test ->
                  submask = if{@mask === true, @mask, @mask[pos]}
                  if submask:
                     m = TestMask{sub[pos], test, submask}
                     newpath = if{sub.length == 1, path, path ++ {pos}}
                     gens.push with {} -> m.generator{newpath}
                  pos += 1
            catch error:
               gens.push with #error{path, error, tests.length - pos}
            match kind:
               .suite -> RaceGen{gens each g -> g{}}
               .seqsuite -> SeqGen{gens}


async! formatTests{tsts} =
   error_reports = {}

   var successes = 0
   var failures = 0
   var errors = 0

   stream = process.stdout
   tick{} =
      stream.clearLine{}
      stream.cursorTo{0}
      stream.write{"Successes: " + successes + ", Failures: " + failures + ", Errors: " + errors}

   fmtp{path} =
      [p.join{" => "}] where p = path each
         Number? n -> "Test #" + n
         s -> s

   tg = await tsts.generator{}
   var curr = await tg.next{}

   while not curr.done:
      test = curr.value
      match test:
         #testResult{path, test, x} ->
            match [await x]:
               #success ->
                  successes += 1
                  tick{}
               #failure ->
                  failures += 1
                  tick{}
                  var report = "FAILURE: " + fmtp{path} + "\n"
                  report += "SOURCE: " + test.source + "\n"
                  error_reports.push with report
               #error{error} ->
                  errors += 1
                  tick{}
                  var report = "ERROR: " + fmtp{path} + "\n"
                  report += "SOURCE: " + test.source + "\n"
                  report += String{error} + "\n"
                  error_reports.push with report
         #error{path, suite, error, count} ->
            errors += count
            tick{}
            var report = "ERROR: " + fmtp{path} + "\n"
            report += count + " tests could not be run because of this error." + "\n"
            error_reports.push with report

      curr = await tg.next{}

   console.log{}

   error_reports each report ->
      console.log with "\n==========="
      console.log with report

   console.log with "Done."

   pass
