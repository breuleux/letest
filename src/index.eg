

provide:
   tests
   TestMask
   Test
   TestSuite
   formatTests

   
global.___letest_global = exports


class RaceGen:

   constructor{@promises} =
      @n = 0
      @proms = {}
      @marks = {}
      @add{@promises}

   add{promises} =
      promises each p ->
         mark = {=}
         @marks.push{mark}
         @proms.push{async{{} -> {mark, await p}}{}}
      @n += promises.length

   async! next{} =
      if @n == 0:
         {value = undefined, done = true}
      else:
         {mark, res} = await Promise.race{@proms}
         i = @marks.indexOf{mark}
         @proms.splice{i, 1}
         @marks.splice{i, 1}
         @n -= 1
         match res:
            RaceGen? ->
               @add{res.promises}
               @next{}
            else ->
               {value = res, done = false}


tests{ctx, scope, form, #data{descr, _body}} =

   letest = #variable{"___letest_global"}

   parseDescription{match d} =
      #value{String! s} ->
         tags = [s.match{R.g"#[a-zA-Z0-9_-]+"} or {}] each
            tag -> #value{tag.slice{1}}
         {d, `{^*tags}`}
      #void{} ->
         {`""`, `{}`}
      else ->
         throw E.letest.syntax.description{"Invalid description.", {node = d}}

   processSuite{#multi! #multi{*stmts}} =

      {let body, let tests} = match stmts:
         {`do: ^[#multi! #multi{*b}]`, *rest} ->
            {#multi{*b}, rest}
         xs ->
            {#multi{}, xs}

      var index = 0
      let gene = #data{}
      let descrs = #data{}

      tests each match test ->
         `do: ^_` ->
            throw E.letest.syntax{
               "do: statement must be at the beginning of the block."
               {node = test}
            }
         `^descr => ^b` ->
            {txt, tags} = parseDescription{descr}
            {g, s} = processSuite{b}
            gene.push with g
            descrs.push with `#suite{^txt, ^tags, ^s}`
         expr ->
            gene.push with `async{{} -> ^expr}`
            descrs.push with `#test{^=index, null, null}`
            index += 1

      body.push{gene}
      {`async{{} -> ^body}`, descrs}

   {v, description, body} = match descr:
      v and #symbol{name} ->
         {v, #value{"#" + name}, _body}
      #send{v and #symbol{name}, `{^ #value{descr}}` or #value{descr}} ->
         {v, #value{String{descr} + " #" + name}, _body}

   {gene, trees} = processSuite{body}
   {d, t} = parseDescription{description}

   `[^v = [^letest].TestSuite{#suite{^d, ^t, ^trees}, ^gene}]`


class TestSuite:

   constructor{@descr, @gen} =
      pass

   select{white = true, black = {}} =
      trim{arr} =
         var i = arr.length - 1
         while i > 0 and arr[i] === false:
            arr.pop{}
            i -= 1
         arr

      {_, text, tags, subdescr} = @descr
      var count = 0
      mask = helper{tags, subdescr, false} where
         helper{t, sd, default} =
            if sd === null:
               if default: count += 1
               default
            elif matchtags{t, black}:
               false
            elif white === true or matchtags{t, white}:
               res = sd each {_, _, t, sd} -> helper{t, sd, true}
               res.every{{x} -> x === true} or trim{res}
            else:
               res = sd each {_, _, t, sd} -> helper{t, sd, default}
               res.every{{x} -> x === true} or [res.some{{x} -> x} and trim{res}]

      TestMask{@descr, @gen, mask, count}

   execute{} =
      @select{true}.execute{}


class Test:
   constructor{@test, @source} =
      pass
   async! execute{} =
      try:
         match [await @test{}]:
            === true ->
               #success{}
            === false ->
               #failure{}
            res and [#success or #failure] ->
               res
            other ->
               #error{E.tests.protocol{..., other}} with
                  "Tests must return true, false, #success{...} or #failure{...}"
      catch error:
         #error{error}


matchtags{tags1, tags2} =
   tags1 each t1 ->
      tags2 each t2 ->
         if t1 == t2:
            return true
      pass
   false


class TestMask:

   constructor{@descr, @gen, @mask, @count = 0} =
      pass

   async! generateTests{var path = {}} =
      match @descr:
         when @mask === false ->
            RaceGen with {}
         #test{*} ->
            RaceGen with {#test{path, Test{@gen, null}}}
         #suite{d, t, sub} ->
            if Number? path[path.length - 1]:
               path[path.length - 1] = d
            else:
               path ++= {d}
            var pos = 0
            var gens = {}
            try:
               let tests = await @gen{}
               tests each test ->
                  match if{@mask === true, @mask, @mask[pos]}:
                     undefined? ->
                        break
                     false? ->
                        pass
                     submask ->
                        m = TestMask{sub[pos], test, submask}
                        newpath = if{sub.length == 1, path, path ++ {pos}}
                        gens.push with m.generateTests{newpath}
                  pos += 1
            catch error:
               gens.push with #error{path, error, tests.length - pos}
            RaceGen{gens}

   async! generateResults{} =
      tg = await @generateTests{}
      self = {
         async! next{} =
            {value => test, => done} = await tg.next{}
            if done:
               return {value = undefined, done = true}
            rval = match test:
               #test{path, t} ->
                  #testResult{path, t, await t.execute{}}
               #error ->
                  test
            {value = rval, done = false}
      }


async! formatTests{tsts} =
   error_reports = {}

   var successes = 0
   var failures = 0
   var errors = 0

   stream = process.stdout
   tick{} =
      stream.clearLine{}
      stream.cursorTo{0}
      stream.write{"Successes: " + successes + ", Failures: " + failures + ", Errors: " + errors}

   fmtp{path} =
      [p.join{" => "}] where p = path each
         Number? n -> "Test #" + n
         s -> s

   tg = await tsts.generateResults{}
   var curr = await tg.next{}

   while not curr.done:
      test = curr.value
      match test:
         #testResult{path, test, x} ->
            match [await x]:
               #success ->
                  successes += 1
                  tick{}
               #failure ->
                  failures += 1
                  tick{}
                  var report = "FAILURE: " + fmtp{path} + "\n"
                  report += "SOURCE: " + test.source + "\n"
                  error_reports.push with report
               #error{error} ->
                  errors += 1
                  tick{}
                  var report = "ERROR: " + fmtp{path} + "\n"
                  report += "SOURCE: " + test.source + "\n"
                  report += String{error} + "\n"
                  error_reports.push with report
         #error{path, suite, error, count} ->
            errors += count
            tick{}
            var report = "ERROR: " + fmtp{path} + "\n"
            report += count + " tests could not be run because of this error." + "\n"
            error_reports.push with report

      curr = await tg.next{}

   console.log{}

   error_reports each report ->
      console.log with "\n==========="
      console.log with report

   console.log with "Done."

   pass
